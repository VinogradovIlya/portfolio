# D01_LINUX-1

1. [Part 1. Установка ОС](#part-1-установка-ос)
2. [Part 2. Создание пользователя](#part-2-создание-пользователя)
3. [Part 3. Настройка сети ОС](#part-3-настройка-сети-ос)
4. [Part 4. Обновление ОС](#part-4-обновление-ос)
5. [Part 5. Использование команды sudo](#part-5-использование-команды-sudo)
6. [Part 6. Установка и настройка службы времени](#part-6-установка-и-настройка-службы-времени)
7. [Part 7. Установка и использование текстовых редакторов](#part-7-установка-и-использование-текстовых-редакторов)
8. [Part 8. Установка и базовая настройка сервиса SSHD](#part-8-установка-и-базовая-настройка-сервиса-sshd)
9. [Part 9. Установка и использование утилит top, htop](#part-9-установка-и-использование-утилит-top-htop)
10. [Part 10. Использование утилиты fdisk](#part-10-использование-утилиты-fdisk)
11. [Part 11. Использование утилиты df](#part-11-использование-утилиты-df)
12. [Part 12. Использование утилиты du](#part-12-использование-утилиты-du)
13. [Part 13. Установка и использование утилиты ncdu](#part-13-установка-и-использование-утилиты-ncdu)
14. [Part 14. Работа с системными журналами](#part-14-работа-с-системными-журналами)
15. [Part 15. Использование планировщика заданий CRON](#part-15-использование-планировщика-заданий-cron)

## Part 1. Установка ОС

Ввожу в терминал: `cat /etc/issue` и вижу следующее  
![task1.png](image/task1.png)

## Part 2. Создание пользователя

С помощью `sudo useradd -m -d /home/adm/ user1 ` я создаю user1 в директории adm, и далее с помощью `cat /etc/passwd` я
вывожу всех пользователей.  
![task2.png](image/task2.png)

## Part 3. Настройка сети ОС

- для того чтобы задать название машины вида user-1 я делаю
  следующее: `hostnamectl set-hostname "user-1" --static`  ![task3.1.png](image/task3.1.png)
- для того, чтобы установить временную зону соответсвующюю моему местоположению я делаю
  следующее:  ![task3.png](image/task3.png)
- для того чтобы вывести названия сетевых инетрфейсов я делаю `ls /sys/class/net`. Мы видим lo так как: __eth0__ –
  интерфейс,
  связанный с сетевой картой, работающей через Ethernet (по кабелю). В выводе выше можно увидеть множество полезной
  информации, например, ip-адрес, привязанный к этому интерфейсу. Если бы сетевых карт было несколько, то кроме eth0, мы
  бы увидели eth1 и так далее.  __lo__ (loopback device) – виртуальный интерфейс, присутствующий по умолчанию в любом
  Linux. Он используется для отладки сетевых программ и запуска серверных приложений на локальной машине. С этим
  интерфейсом всегда связан адрес 127.0.0.1.
  У него есть dns-имя – localhost.  ![task3.3.png](image/task3.3.png)
- чтобы узнать локальный ip адрес я сделал `ping -c 3 localhost`  ![task3.4.png](image/task3.4.png)
- получение IP адреса устройства от DHCP сервера с помощью `ip addr show`, вывод внутреннего IP
  адреса `ip route | grep default`, вывод внешнего
  IP-адреса `curl -s ifconfig.me` ![task3.5.png](image/task3.5.png)
- DHCP - это сетевой протокол, который позволяет автоматически назначать подключаемым к сети устройствам IP - адреса и
  другие параметры конфигурации
### Network interfaces
Сетевые интерфейсы предназначены для передачи данных между программами через компьютерную сеть. \
В Linux любые данные, которые компьютер отправляет в сеть или получает из сети, проходят через сетевой интерфейс. \
Сетевые интерфейсы могут быть как физическими, так и виртуальными. \
Вот примеры типов сетевых интерфейсов:
- eth -- Сетевой интерфейс к карте Ethernet или картам WaveLan (Radio Ethernet).
- ax -- Сетевой интерфейс к устройствам любительского радио AX.25.
- arc0e, arc0s -- Сетевой интерфейс к карте ArcNet. Используется инкапсуляция пакетов в формате Ethernet или RFC 1051.
- wlan -- Сетевой интерфейс wi-fi адаптеров.

### DHCP
Для работы по сети любому устройству требуется IP-адрес. В протоколе IPv4 это числовой идентификатор, состоящий из 4 разрядов, каждый из которых отделяется точкой, без него устройство не может быть определено в сетевой инфраструктуре. \
Прикладной протокол DHCP выполняет всю работу по подбору сетевых настроек автоматически, без необходимости присваивать вручную каждому устройству свой IP-адрес. Это очень упрощает работу системного администратора в случае расширения сети.
- для того чтобы узнать внешний ip адрес Я делаю `wget -qO- eth0.me`  ![task3.6.png](image/task3.6.png)
- для того чтобы узнать внутренний ip адрес шлюза Я ввожу `ip route | grep default`  ![task3.7.png](image/task3.7.png)
- для того чтобы задать статический ip, gw, dns Я делаю следующее:
    - меняю в `sudo vim /etc/netplan/*.yaml`  ![task3.8.png](image/task3.8.png)
    - далее `sudo netplan apply`
    - ping -c 3 ya.ru
    - ping -c 3 8.8.8.8

## Part 4. Обновление ОС
с помощью `sudo apt update && sudo apt upgrade` Я могу обновить систему  ![task4.png](image/task4.png)

## Part 5. Использование команды sudo
sudo (от superuser do) — это команда в Unix-подобных системах (например, Linux или macOS), которая позволяет запускать программы или команды от имени администратора (пользователя root) или другого пользователя с повышенными правами.
 
Основные моменты:  
Root-пользователь: В Linux root — это суперпользователь, который имеет полный доступ к системе, включая изменение системных файлов, установку программ и другие действия, требующие административных привилегий.
Для чего нужен sudo: Не рекомендуется работать постоянно под root, чтобы избежать случайных ошибок (например, удаления важных системных файлов). Вместо этого, обычные пользователи могут временно повышать привилегии с помощью sudo, чтобы выполнить действия, требующие прав администратора.

Чтобы поменять hostname от имени пользователя надо переключиться на пользователя user1 (пароль Я ему не задавал поэтому Я установил ему пароль с помощью `sudo passwd user1`) и далее дал ему права от имени суперпользователя (`su -i` чтобы переключиться и далее `usermod -aG sudo user1`), после переключившись на user1 (`su user1`) с помощью `sudo hostnamectl set-hostname new-hostname` Я поменял hostname и проверил это с помощью `hostnamectl`.  ![task5.png](image/task5.png)

## Part 6. Установка и настройка службы времени
с помощью `sudo timedatectl show` Я могу увидеть NTPSynchronized. С помощью `sudo timedatectl set-ntp true` Я могу установить NTPSynchronized=yes и с помощью `sudo timedatectl set-timezone Europe/Moscow` Я могу настроить конкретное время  ![tesk6](image/task6.png)

## Part 7. Установка и использование текстовых редакторов
### Создание и выход (с сохранением и без)
Чтобы создать файл в vim Я:
- `vim test_vim.txt`
- `i`
- `willames`
- `ZZ`

![task7.1](image/task7.1.png)

выйти без сохранения: `:q!`

![task7.11](image/task7.11.png)

Чтобы создать файл в nano Я:
- `nano test_nano.txt`
- `willames`
- `CTRL + O`+ ENTER
- `CTRL + X`

![task7.2](image/task7.2.png)

выйти без сохранения: `CTRL + X` + `N`

![task7.22](image/task7.22.png)

Чтобы создать файл в joe Я:
- `joe test_joe.txt`
- `willames`
- `CTRL + K`+ `X`

![task7.3](image/task7.3.png)

выйти без сохранения: `CTRL + C`

![task7.33](image/task7.33.png)

### Замена

Лично Я люблю vim и чтобы найти что-то в vim нужно сделать `/слово` и далее можно с помощью n (следующее) или N (предыдущее) идти по совпадениям слов или `?слово` так можно искать по файлу к началу файла или к концу файла.  ![task7.1111](image/task7.1111.png)  
Для замены слова в vim можно сделать `:s/willames/новое слово`  ![task7.111](image/task7.111.png)  

Чтобы найти слово в nano нужно сделать `CTRL + W` и вводим слово для поиска.  ![task7.2222](image/task7.2222.png)  
Для замены слова в nano можно сделать `CTRL + \` далее слово для поиска и слово для замены  ![task7.222](image/task7.222.png)

Для поиска в joe `CTRL + K + F`
Затем выберите между опциями игнорировать (I) и заменить (R). Для перехода к следующему результату используйте: `Ctrl + L` ![task7.3333](image/task7.3333.png), далее `R` слово для поиска и слово для замены.  ![task7.333](image/task7.333.png)

## Part 8. Установка и базовая настройка сервиса SSHD
### Установка SSHD в Ubuntu Linux
в параметрах команды apt-get указывается имя мета пакета ssh: `sudo apt-get install ssh`  
Данная команда установит пакеты openssh-client и openssh-server одновременно.

### Настройка SSHD сервера
Настройка SSHD на компьютере, к которому подключаемся извне  
Вначале копирую в bak, т.е. откладываю в сторону исходный конфигурационный файл SSHD: `sudo cp /etc/ssh/sshd_config /etc/ssh/sshd_config.COPY`  
Исправляю конфигурационный файл по инструкции с учётом того, что вход будет осуществляться по паролю.  
Исправил его с помощью редактора "vim": `sudo vim /etc/ssh/sshd_config`  ![task8.1](image/task8.1.png)  
Перезапуск демона sshd для применения изменений в файле конфигурации на сервере (главном ПК): `sudo systemctl restart ssh`  

### Настройка запуска службы SSHD на сервере Ununtu
Служба SSHD используется на сервере для удаленного администрирования сервера, для подключения к нему извне.  
Разрешение постоянного запуска службы SSHD при загрузке операционной системы - по имени сервиса ssh.service: `sudo systemctl enable ssh`  
Перезапуск демона sshd для применения изменений в файле конфигурации на сервере (главном ПК): `sudo systemctl restart ssh`  

Имя службы одно - ssh. Название sshd - псевдоним (алиас). Если обратиться к службе ssh по имени sudo systemctl enable sshd.service - команда не сработает (ошибка "Failed to restart sshd.service: Unit sshd.service not found."). Потому что основная служба называется ssh.service, а её псевдоним - sshd.service. Вывод: для управления службой sshd используется имя службы ssh. Команды sudo systemctl restart ssh и sudo systemctl restart sshd делают одно и то же, но первая предпочтительней.

### PS
С помощью `ps aux | grep sshd`
- ps -- команда для отображения информации о запущенных процессах
- a -- включает процессы всех пользователей
- u -- показывает процессы в развернутом виде, включая информацию о пользователе и процессах
- x -- отображает также процессы, не привязанные к определенному терминалу (например, демоны)

### Перезагрузка системы
`sudo reboot`

### Настройка локального брандмауэра UFW
Запустить и разрешить запуск ufw после перезагрузки, одной командой: `sudo systemctl enable --now ufw`  
Проверка: `sudo systemctl status ufw`  
Чтобы открыть "секретный" порт 2022 сервера sshd на брандмауэре, я выполнил команду, которая добавляет разрешающее правило: `sudo ufw allow 2022`
Просмотр правил брандмауэра ufw: `sudo ufw show added`  

### Подключение к серверу SSH от клиента
Если сервер имеет статический "белый" IP-адрес, подключение к нему с клиента выполняется командой `ssh willames@10.0.0.2 -p 2022`
где willames - логин пользователя, который должен существовать на сервере,
10.0.0.2 - IP адрес сервера,
2022 - порт SSH.

При первом подключении будет сообщение о доверии к серверу, ответил с клавиатуры "yes".
Затем нужно ввести пароль к учётной записи user, и вы попадёте в консоль (терминальную сессию) сервера.

### Выход
После работы с сервером можно от него отключиться с помощью команды `exit`

### netstat -tan
- t -- показывает только соединение на основе tcp
- a -- отображает все активные соединения и порты, которые находятся в состоянии LISTEN
- n -- выводит номера портов, вместо попытки их преобразовывать в имена
![task8.1](image/task8.2.png)

Proto: Протокол (например, TCP).
Recv-Q: Очередь входящих данных, ожидающих обработки (в байтах).
Send-Q: Очередь исходящих данных, ожидающих отправки (в байтах).
Local Address: Локальный IP-адрес и порт ожидания подключения (например, 0.0.0.0:2022).
Foreign Address: Удалённый IP-адрес и порт подключения (например, 0.0.0.0:* означает, что подключение возможно с любого адреса).
State: Состояние соединения. LISTEN показывает, что порт открыт и ожидает подключения.

### Значение 0.0.0.0:
Адрес 0.0.0.0 в поле Local Address означает, что процесс принимает подключения на всех сетевых интерфейсах (то есть служба доступна по любому IP-адресу машины).

## Part 9. Установка и использование утилит top, htop
### top
![task9.1](image/task9.1.png)
- uptime -- 28 min
- количество авторизованных пользователей -- 1
- среднюю загрузку системы (load average) -- 0.00 0.01 0.00 (минута, пять, пятнадцать)
- общее количество процессов (tasks) -- 104
- загрузку cpu -- 0.0 us (user space) 0.2 sy (system space) 99.7 id (простой CPU)
- загрузку памяти -- 3916.1 total 3405.9 free 421.6 used
- pid процесса занимающего больше всего памяти -- (нажав М) 351  ![task9.11](image/task9.12.png)
- pid процесса, занимающего больше всего процессорного времени -- (нажав P) 1305  ![task9.12](image/task9.12.png)

### htop
![task9.2](image/task9.2.png)
- отсортированному по PID, PERCENT_CPU, PERCENT_MEM, TIME;
  - нажав f6 можно открыть настройки для сортировки  ![task9.search](image/task9.21.png)  ![task9. pid](image/task9.22.png)  ![task9.cpu](image/task9.23.png)  ![task9.mem](image/task9.24.png)  ![task9.time](image/task9.25.png)
- чтобы отсортировать по процессам нужно нажать f3
  - отфильтрованному для процесса sshd  ![task9.ssh](image/task9.26.png)
  - с процессом syslog, найденным, используя поиск  ![task9.syslog](image/task9.27.png)  
  называется messagebus как служба для коммуникации между процессами

- чтобы дополнительно вывести данные нужно нажать f2 Setup -> Meters, и добавить Hostname, clock, uptime  ![task9](image/task9.28.png)  
- с добавленным выводом hostname, clock и uptime.  ![task9](image/task9.29.png) 

## Part 10. Использование утилиты fdisk

![task10](image/task10.png)

Название обозначается как /dev/sdX, где X - буква, в моем случае Disk /dev/sda. Размер 15 Gb, 31457280 сектора

## Part 11. Использование утилиты df

![task11](image/task11.png)

`df`
- размер 15372232
- используется 3223600
- свободно 11345972
- процент использования 23 %
вывод  в килобайтах

`df -Th`
- размер 15 gb
- используется 3.1 gb
- свободно 11 gb
- процент использования 23 %
- тип файловой системы ext4

## Part 12. Использование утилиты du

![task12](image/task12.1.png)

![task12](image/task12.2.png)

## Part 13. Установка и использование утилиты ncdu

![task13](image/task13.1.png)

![task13](image/task13.2.png)

![task13](image/task13.3.png)

## Part 14. Работа с системными журналами

![task14](image/task14.1.png)

![task14](image/task14.2.png)

![task14](image/task14.3.png)

![task14](image/task14.31.png)

время 7:37:54
пользователь willames (ROOT)
метод входа TTY=tty1

## Part 15. Использование планировщика заданий CRON

с помощью `crontab -e` Я открыл редактор задач CRON и добавляю задачу из [task15](image/task15.2.png)

с помощью `sudo grep CRON /var/log/syslog` Я отображаю вызовы команды uptime
![task15](image/task15.1.png)

с помощью `crontab -l` и `crontab -r` могу показать список задач и очистить его
![task15](image/task15.2.png)